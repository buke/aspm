// Generated by CoffeeScript 1.8.0
(function() {
  var buildModule, exec, fetchModule, fs, os, path, queue, rmDirRecursiveSync;

  fs = require('fs');

  path = require('path');

  os = require('os');

  exec = require('child_process').exec;

  queue = require('queue-async');

  require('terminal-colors');

  rmDirRecursiveSync = function(dirPath) {
    var e, filePath, files, i;
    try {
      files = fs.readdirSync(dirPath);
    } catch (_error) {
      e = _error;
      return;
    }
    if (files.length > 0) {
      i = 0;
      while (i < files.length) {
        filePath = dirPath + "/" + files[i];
        if (fs.statSync(filePath).isFile()) {
          fs.unlinkSync(filePath);
        } else {
          rmDirRecursiveSync(filePath);
        }
        i++;
      }
    }
    try {
      fs.rmdirSync(dirPath);
    } catch (_error) {}
  };

  module.exports.fetchModule = fetchModule = function(module, program, cb) {
    var child, cmd;
    if (!program.quiet) {
      console.log("fetching " + (module || 'all'));
    }
    if (module == null) {
      module = '';
    }
    if (program.tarball) {
      module = program.tarball;
    }
    cmd = "npm install --ignore-scripts " + module;
    if (program.save) {
      cmd += ' --save';
    }
    if (program['save-dev']) {
      cmd += ' --save-dev';
    }
    if (!program['no-production']) {
      cmd += ' --production';
    }
    if (!program.quiet) {
      console.log(("> " + cmd).lightBlue);
    }
    child = exec(cmd);
    if (!program.quiet) {
      child.stdout.pipe(process.stdout);
    }
    child.stderr.pipe(process.stderr);
    child.on('exit', function(code) {
      if (code !== 0) {
        return typeof cb === "function" ? cb(new Error("not ok")) : void 0;
      }
      return typeof cb === "function" ? cb() : void 0;
    });
  };

  module.exports.buildModule = buildModule = function(module, program, cb) {
    var arch, buildPkg, child, cmd, config, fakeNodePreGyp, module_path, modules, platform, preGyp, projectPkg, q, target, _i, _len, _ref, _ref1;
    projectPkg = require(path.join(process.cwd(), 'package.json'));
    config = (_ref = projectPkg.config) != null ? _ref['atom-shell'] : void 0;
    target = program.target || (config != null ? config.version : void 0);
    arch = program.arch || (config != null ? config.arch : void 0);
    platform = program['target-platform'] || (config != null ? config['platform'] : void 0) || os.platform();
    modules = [];
    if (!fs.existsSync(path.join(process.cwd(), 'node_modules', module, 'binding.gyp'))) {
      return cb();
    }
    if (!target) {
      return typeof cb === "function" ? cb(new Error("no atom-shell version specified.")) : void 0;
    }
    if (!arch) {
      return typeof cb === "function" ? cb(new Error("no target architecture specified.")) : void 0;
    }
    if (module.indexOf(' ') !== -1) {
      modules = module.split(' ');
    }
    if (!module) {
      modules = Object.keys(projectPkg.dependencies);
    }
    if (modules.length !== 0) {
      q = queue(1);
      for (_i = 0, _len = modules.length; _i < _len; _i++) {
        module = modules[_i];
        q.defer(buildModule, module);
        q.awaitAll(function(err) {
          return cb();
        });
      }
      return;
    }
    if (!program.quiet) {
      console.log("building " + module + " for Atom-Shell v" + target + " " + (os.platform()) + " " + arch);
    }
    buildPkg = require(path.join(process.cwd(), 'node_modules', module, 'package.json'));
    fakeNodePreGyp = (((_ref1 = buildPkg.dependencies) != null ? _ref1['node-pre-gyp'] : void 0) != null) && (buildPkg.binary != null);
    if (fakeNodePreGyp) {
      module_path = buildPkg.binary.module_path;
      module_path = module_path.replace('{node_abi}', "atom-shell-v" + target).replace('{platform}', os.platform()).replace('{arch}', arch);
      preGyp = {
        module_name: buildPkg.binary.module_name,
        module_path: path.join('..', module_path)
      };
    }
    cmd = "node-gyp rebuild --target=" + target + " --arch=" + arch + " --target_platform=" + platform + " --dist-url=https://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist";
    if (fakeNodePreGyp) {
      cmd += " --module_name=" + preGyp.module_name;
      cmd += " --module_path=" + preGyp.module_path;
    }
    if (!program.quiet) {
      console.log(("> " + cmd).lightBlue);
    }
    child = exec(cmd, {
      cwd: "node_modules/" + module
    });
    if (!program.quiet) {
      child.stdout.pipe(process.stdout);
    }
    child.stderr.pipe(process.stderr);
    child.on('exit', function(code) {
      if (code !== 0) {
        return typeof cb === "function" ? cb(new Error("not ok")) : void 0;
      }
      if (!fakeNodePreGyp) {
        try {
          fs.mkdirSync("node_modules/" + module + "/lib/binding");
        } catch (_error) {}
        fs.renameSync("node_modules/" + module + "/build/Release/node_" + module + ".node", "node_modules/" + module + "/lib/binding/node_" + module + ".node");
      }
      rmDirRecursiveSync("node_modules/" + module + "/build/");
      return typeof cb === "function" ? cb() : void 0;
    });
  };

  module.exports.installModule = function(module, program, cb) {
    if (!program.quiet) {
      console.log("installing " + (module || 'all'));
    }
    fetchModule(module, program, function(err) {
      if (err) {
        return typeof cb === "function" ? cb(err) : void 0;
      }
      buildModule(module, program, function(err) {
        return typeof cb === "function" ? cb(err) : void 0;
      });
    });
  };

}).call(this);
