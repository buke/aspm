// Generated by CoffeeScript 1.8.0
var buildModule, configureModule, exec, fetchModule, fs, os, path, queue, rmDirRecursiveSync, runCmd, semver;

fs = require('fs');

path = require('path');

os = require('os');

exec = require('child_process').exec;

queue = require('queue-async');

semver = require('semver');

require('terminal-colors');

rmDirRecursiveSync = function(dirPath) {
  var e, filePath, files, i;
  try {
    files = fs.readdirSync(dirPath);
  } catch (_error) {
    e = _error;
    return;
  }
  if (files.length > 0) {
    i = 0;
    while (i < files.length) {
      filePath = dirPath + "/" + files[i];
      if (fs.statSync(filePath).isFile()) {
        fs.unlinkSync(filePath);
      } else {
        rmDirRecursiveSync(filePath);
      }
      i++;
    }
  }
  try {
    fs.rmdirSync(dirPath);
  } catch (_error) {}
};

module.exports.runCmd = runCmd = function(cmd, opts, quiet, cb) {
  var child, errMsg;
  if (!quiet) {
    console.log(("" + (opts.cwd || '') + "> " + cmd).lightBlue);
  }
  errMsg = '';
  child = exec(cmd, opts);
  if (!quiet) {
    child.stdout.pipe(process.stdout);
  }
  if (!quiet) {
    child.stderr.pipe(process.stderr);
  } else {
    child.stderr.on('data', function(chunk) {
      errMsg += chunk;
    });
  }
  child.on('exit', function(code) {
    if (code !== 0) {
      return typeof cb === "function" ? cb(new Error("command failed: " + cmd + "\n" + errMsg)) : void 0;
    }
    return typeof cb === "function" ? cb() : void 0;
  });
};

configureModule = function(moduleName, opts, nodePreGypParams, cb) {
  var cmd, cmdOpts;
  cmd = "node-gyp configure " + nodePreGypParams;
  cmdOpts = {
    cwd: path.join('node_modules', moduleName)
  };
  if (opts.cwd) {
    cmdOpts.cwd = path.join(opts.cwd, cmdOpts.cwd);
  }
  runCmd(cmd, cmdOpts, opts.quiet, cb);
};

module.exports.fetchModule = fetchModule = function(moduleName, opts, cb) {
  var cmd, cmdOpts;
  if (!opts.quiet) {
    console.log("fetching " + (moduleName || 'all'));
  }
  if (moduleName == null) {
    moduleName = '';
  }
  if (opts.tarball) {
    moduleName = opts.tarball;
  }
  cmd = "npm install " + moduleName;
  if (!opts.runScripts) {
    cmd += ' --ignore-scripts';
  }
  if (opts.save) {
    cmd += ' --save';
  }
  if (opts.saveDev) {
    cmd += ' --save-dev';
  }
  cmdOpts = {};
  if (opts.cwd) {
    cmdOpts.cwd = opts.cwd;
  }
  runCmd(cmd, cmdOpts, opts.quiet, cb);
};

module.exports.buildModule = buildModule = function(moduleName, opts, cb) {
  var arch, buildPkg, cmd, cmdOpts, config, cwd, fakeNodePreGyp, modulePath, module_path, modules, nodePreGypParams, nodePreGypPkg, nodePreGypVersion, node_abi, platform, preGyp, preScripts, projectPkg, q, scriptName, target, _i, _j, _len, _len1, _ref, _ref1, _ref2;
  projectPkg = require(path.join(process.cwd(), 'package.json'));
  config = (_ref = projectPkg.config) != null ? _ref['atom-shell'] : void 0;
  target = opts.target || (config != null ? config.version : void 0);
  arch = opts.arch || (config != null ? config.arch : void 0);
  platform = opts['target-platform'] || (config != null ? config['platform'] : void 0) || os.platform();
  modules = [];
  nodePreGypParams = '';
  if (moduleName.indexOf(' ') !== -1) {
    modules = moduleName.split(' ');
  }
  if (!moduleName) {
    modules = Object.keys(projectPkg.dependencies);
  }
  if (modules.length !== 0) {
    q = queue(1);
    for (_i = 0, _len = modules.length; _i < _len; _i++) {
      moduleName = modules[_i];
      q.defer(buildModule, moduleName);
      q.awaitAll(function(err) {
        return cb();
      });
    }
    return;
  }
  moduleName = moduleName.split('@')[0];
  cwd = process.cwd();
  if (opts.cwd) {
    cwd = path.join('..', opts.cwd);
  }
  modulePath = path.join(cwd, 'node_modules', moduleName);
  if (!fs.existsSync(path.join(modulePath, 'package.json'))) {
    return typeof cb === "function" ? cb(new Error("aspm: module not found '" + moduleName + "'")) : void 0;
  }
  if (!fs.existsSync(path.join(modulePath, 'binding.gyp'))) {
    return cb();
  }
  if (!target) {
    return typeof cb === "function" ? cb(new Error("aspm: no atom-shell version specified.")) : void 0;
  }
  if (!arch) {
    return typeof cb === "function" ? cb(new Error("aspm: no target architecture specified.")) : void 0;
  }
  buildPkg = require(path.join(modulePath, 'package.json'));
  fakeNodePreGyp = (((_ref1 = buildPkg.dependencies) != null ? _ref1['node-pre-gyp'] : void 0) != null) && (buildPkg.binary != null);
  if (fakeNodePreGyp) {
    nodePreGypPkg = require(path.join(modulePath, 'node_modules', 'node-pre-gyp', 'package.json'));
    nodePreGypVersion = nodePreGypPkg.version;
    node_abi = "atom-shell-v" + target;
    if (semver.lte(nodePreGypVersion, '999.0.0')) {
      node_abi = (function() {
        var atomshellToModulesVersion, atomshellToNodeVersion, lookupTable, targetParts, targetSimplified;
        atomshellToModulesVersion = {
          '0.20.x': 17,
          "0.19.x": 16,
          "0.18.x": 16,
          "0.17.x": 15,
          "0.16.x": 14
        };
        atomshellToNodeVersion = {
          '0.20.x': '0.13.0-pre',
          '0.19.x': '0.11.14',
          '0.18.x': '0.11.14',
          '0.17.x': '0.11.14',
          '0.16.x': '0.11.13'
        };
        lookupTable = (function() {
          if (semver.lt(nodePreGypVersion, '0.6.0')) {
            return atomshellToModulesVersion;
          }
          return atomshellToNodeVersion;
        })();
        targetParts = target.split('.');
        targetParts[2] = 'x';
        targetSimplified = targetParts.join('.');
        return "node-v" + lookupTable[targetSimplified];
      })();
    }
    module_path = buildPkg.binary.module_path;
    module_path = module_path.replace('{node_abi}', node_abi).replace('{platform}', os.platform()).replace('{arch}', arch).replace('{module_name}', buildPkg.binary.module_name).replace('{configuration}', 'Release').replace('{version}', buildPkg.version);
    preGyp = {
      module_name: buildPkg.binary.module_name,
      module_path: path.join('..', module_path)
    };
  }
  if (fakeNodePreGyp) {
    nodePreGypParams += " --module_name=" + preGyp.module_name;
    nodePreGypParams += " --module_path=" + preGyp.module_path;
  }
  q = queue(1);
  preScripts = 'prepublish preinstall'.split(' ');
  if (opts.compatibility) {
    preScripts.push('install');
  }
  cmdOpts = {
    cwd: path.join('node_modules', moduleName)
  };
  if (opts.cwd) {
    cmdOpts.cwd = path.join(opts.cwd, cmdOpts.cwd);
  }
  for (_j = 0, _len1 = preScripts.length; _j < _len1; _j++) {
    scriptName = preScripts[_j];
    if (((_ref2 = buildPkg.scripts) != null ? _ref2[scriptName] : void 0) != null) {
      cmd = "npm run " + scriptName;
      q.defer(runCmd, cmd, cmdOpts, opts.quiet);
    }
  }
  q.awaitAll(function(err) {
    configureModule(moduleName, opts, nodePreGypParams, function(err) {
      if (!opts.quiet) {
        console.log("building " + moduleName + " for Atom-Shell v" + target + " " + (os.platform()) + " " + arch);
      }
      cmd = "node-gyp rebuild --target=" + target + " --arch=" + arch + " --target_platform=" + platform + " --dist-url=https://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist " + nodePreGypParams;
      runCmd(cmd, cmdOpts, opts.quiet, function(err) {
        var _k, _len2, _ref3, _ref4;
        if (err) {
          return typeof cb === "function" ? cb(err) : void 0;
        }

        /*
        				unless fakeNodePreGyp
        					 * we move the node_module.node file to lib/binding
        					try fs.mkdirSync "node_modules/#{moduleName}/lib/binding"
        					fs.renameSync "node_modules/#{moduleName}/build/Release/node_#{moduleName}.node", "node_modules/#{moduleName}/lib/binding/node_#{moduleName}.node"
        				rmDirRecursiveSync "node_modules/#{moduleName}/build/"
         */
        q = queue(1);
        _ref3 = 'postinstall'.split(' ');
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          scriptName = _ref3[_k];
          if (((_ref4 = buildPkg.scripts) != null ? _ref4[scriptName] : void 0) != null) {
            cmd = "npm run " + scriptName;
            q.defer(runCmd, cmd, cmdOpts, opts.quiet);
          }
        }
        return q.awaitAll(function(err) {
          return typeof cb === "function" ? cb() : void 0;
        });
      });
    });
  });
};

module.exports.installModule = function(moduleName, opts, cb) {
  if (!opts.quiet) {
    console.log("installing " + (moduleName || 'all'));
  }
  fetchModule(moduleName, opts, function(err) {
    if (err) {
      return typeof cb === "function" ? cb(err) : void 0;
    }
    buildModule(moduleName, opts, function(err) {
      return typeof cb === "function" ? cb(err) : void 0;
    });
  });
};
