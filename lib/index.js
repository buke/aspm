// Generated by CoffeeScript 1.8.0
(function() {
  var buildModule, configureModule, exec, fetchModule, fs, os, path, queue, rmDirRecursiveSync;

  fs = require('fs');

  path = require('path');

  os = require('os');

  exec = require('child_process').exec;

  queue = require('queue-async');

  require('terminal-colors');

  rmDirRecursiveSync = function(dirPath) {
    var e, filePath, files, i;
    try {
      files = fs.readdirSync(dirPath);
    } catch (_error) {
      e = _error;
      return;
    }
    if (files.length > 0) {
      i = 0;
      while (i < files.length) {
        filePath = dirPath + "/" + files[i];
        if (fs.statSync(filePath).isFile()) {
          fs.unlinkSync(filePath);
        } else {
          rmDirRecursiveSync(filePath);
        }
        i++;
      }
    }
    try {
      fs.rmdirSync(dirPath);
    } catch (_error) {}
  };

  configureModule = function(moduleName, program, nodePreGypParams, cb) {
    var child, cmd;
    cmd = "node-gyp configure " + nodePreGypParams;
    if (!program.quiet) {
      console.log(("> " + cmd).lightBlue);
    }
    child = exec(cmd, {
      cwd: "node_modules/" + moduleName
    });
    if (!program.quiet) {
      child.stdout.pipe(process.stdout);
    }
    if (!program.quiet) {
      child.stderr.pipe(process.stderr);
    }
    child.on('exit', function(code) {
      if (code !== 0) {
        return typeof cb === "function" ? cb(new Error("node-gyp configure error")) : void 0;
      }
      return typeof cb === "function" ? cb() : void 0;
    });
  };

  module.exports.fetchModule = fetchModule = function(moduleName, program, cb) {
    var child, cmd;
    if (!program.quiet) {
      console.log("fetching " + (moduleName || 'all'));
    }
    if (moduleName == null) {
      moduleName = '';
    }
    if (program.tarball) {
      moduleName = program.tarball;
    }
    cmd = "npm install --ignore-scripts " + moduleName;
    if (program.save) {
      cmd += ' --save';
    }
    if (program['save-dev']) {
      cmd += ' --save-dev';
    }
    if (!program.quiet) {
      console.log(("> " + cmd).lightBlue);
    }
    child = exec(cmd);
    if (!program.quiet) {
      child.stdout.pipe(process.stdout);
    }
    if (!program.quiet) {
      child.stderr.pipe(process.stderr);
    }
    child.on('exit', function(code) {
      if (code !== 0) {
        return typeof cb === "function" ? cb(new Error("npm install error")) : void 0;
      }
      return typeof cb === "function" ? cb() : void 0;
    });
  };

  module.exports.buildModule = buildModule = function(moduleName, program, cb) {
    var arch, buildPkg, config, fakeNodePreGyp, module_path, modules, nodePreGypParams, platform, preGyp, projectPkg, q, target, _i, _len, _ref, _ref1;
    projectPkg = require(path.join(process.cwd(), 'package.json'));
    config = (_ref = projectPkg.config) != null ? _ref['atom-shell'] : void 0;
    target = program.target || (config != null ? config.version : void 0);
    arch = program.arch || (config != null ? config.arch : void 0);
    platform = program['target-platform'] || (config != null ? config['platform'] : void 0) || os.platform();
    modules = [];
    nodePreGypParams = '';
    if (moduleName.indexOf(' ') !== -1) {
      modules = moduleName.split(' ');
    }
    if (!moduleName) {
      modules = Object.keys(projectPkg.dependencies);
    }
    if (modules.length !== 0) {
      q = queue(1);
      for (_i = 0, _len = modules.length; _i < _len; _i++) {
        moduleName = modules[_i];
        q.defer(buildModule, moduleName);
        q.awaitAll(function(err) {
          return cb();
        });
      }
      return;
    }
    moduleName = moduleName.split('@')[0];
    if (!fs.existsSync(path.join(process.cwd(), 'node_modules', moduleName, 'binding.gyp'))) {
      return cb();
    }
    if (!target) {
      return typeof cb === "function" ? cb(new Error("aspm: no atom-shell version specified.")) : void 0;
    }
    if (!arch) {
      return typeof cb === "function" ? cb(new Error("aspm: no target architecture specified.")) : void 0;
    }
    buildPkg = require(path.join(process.cwd(), 'node_modules', moduleName, 'package.json'));
    fakeNodePreGyp = (((_ref1 = buildPkg.dependencies) != null ? _ref1['node-pre-gyp'] : void 0) != null) && (buildPkg.binary != null);
    if (fakeNodePreGyp) {
      module_path = buildPkg.binary.module_path;
      module_path = module_path.replace('{node_abi}', "atom-shell-v" + target).replace('{platform}', os.platform()).replace('{arch}', arch);
      preGyp = {
        module_name: buildPkg.binary.module_name,
        module_path: path.join('..', module_path)
      };
    }
    if (fakeNodePreGyp) {
      nodePreGypParams += " --module_name=" + preGyp.module_name;
      nodePreGypParams += " --module_path=" + preGyp.module_path;
    }
    configureModule(moduleName, program, nodePreGypParams, function(err) {
      var child, cmd;
      if (!program.quiet) {
        console.log("building " + moduleName + " for Atom-Shell v" + target + " " + (os.platform()) + " " + arch);
      }
      cmd = "node-gyp rebuild --target=" + target + " --arch=" + arch + " --target_platform=" + platform + " --dist-url=https://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist " + nodePreGypParams;
      if (!program.quiet) {
        console.log(("> " + cmd).lightBlue);
      }
      child = exec(cmd, {
        cwd: "node_modules/" + moduleName
      });
      if (!program.quiet) {
        child.stdout.pipe(process.stdout);
      }
      if (!program.quiet) {
        child.stderr.pipe(process.stderr);
      }
      child.on('exit', function(code) {
        if (code !== 0) {
          return typeof cb === "function" ? cb(new Error("node-gyp rebuild error")) : void 0;
        }
        if (!fakeNodePreGyp) {
          try {
            fs.mkdirSync("node_modules/" + moduleName + "/lib/binding");
          } catch (_error) {}
          fs.renameSync("node_modules/" + moduleName + "/build/Release/node_" + moduleName + ".node", "node_modules/" + moduleName + "/lib/binding/node_" + moduleName + ".node");
        }
        rmDirRecursiveSync("node_modules/" + moduleName + "/build/");
        return typeof cb === "function" ? cb() : void 0;
      });
    });
  };

  module.exports.installModule = function(moduleName, program, cb) {
    if (!program.quiet) {
      console.log("installing " + (moduleName || 'all'));
    }
    fetchModule(moduleName, program, function(err) {
      if (err) {
        return typeof cb === "function" ? cb(err) : void 0;
      }
      buildModule(moduleName, program, function(err) {
        return typeof cb === "function" ? cb(err) : void 0;
      });
    });
  };

}).call(this);
